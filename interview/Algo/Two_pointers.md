1. Pair with Target Sum: In this problem, we have to take two variables from both ends. As the array is sorted, we can find the sum of both elements and check whether it is greater than the target sum. If the target sum is greater than the sum of elements in that case increment the left pointer or else decrease the right pointer. Return true or false if you find the sum.
2. Remove Duplicates: Given an array of sorted numbers, remove all duplicate number instances from it in place, such that each element appears only once. The relative order of the elements should be kept the same and you should not use any extra space so that the solution has a space complexity of O(1): In this problem, we have to take 2 pointers one is the start index and the next index. Start iterating from the beginning. If both numbers are not the same increase it if both same then start the index fix it and increase only the other index until find non similar element. Once u find replace with the start index and swap it.
3. Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order: In this problem find the highest square index which is the end of the array. Take 2 more pointers start and end. Iterate the loop until the start is less than the end. Find the square of arr[start] and arr[end]. Now if arr[start] square is greater than arr[end] square then arr[highestIndex--] = arr[start] else arr[highestIndex--] = arr[end]. In this way, we can place the highest numbers post-squaring from the end of the array. 
4. Given an array of unsorted numbers, find all unique triplets in it that add up to zero: Sort the array. Here triplet is 0 means X+Y+Z=0. That means Y+Z = -X. In this case, we can take the first index and take 2 other indexes from the  end and start index +1. The start index can be skipped if it is a similar number. Now the problem is similar to above. Find the sum of the target number. We have to write a condition skip if continuous numbers are similar.
5. 
