1. Pair with Target Sum: In this problem, we have to take two variables from both ends. As the array is sorted, we can find the sum of both elements and check whether it is greater than the target sum. If the target sum is greater than the sum of elements in that case increment the left pointer or else decrease the right pointer. Return true or false if you find the sum.
2. Remove Duplicates: Given an array of sorted numbers, remove all duplicate number instances from it in place, such that each element appears only once. The relative order of the elements should be kept the same and you should not use any extra space so that the solution has a space complexity of O(1): In this problem, we have to take 2 pointers one is the start index and the next index. Start iterating from the beginning. If both numbers are not the same increase it if both same then start the index fix it and increase only the other index until find non similar element. Once u find replace with the start index and swap it.
3. Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order: In this problem find the highest square index which is the end of the array. Take 2 more pointers start and end. Iterate the loop until the start is less than the end. Find the square of arr[start] and arr[end]. Now if arr[start] square is greater than arr[end] square then arr[highestIndex--] = arr[start] else arr[highestIndex--] = arr[end]. In this way, we can place the highest numbers post-squaring from the end of the array. 
4. Given an array of unsorted numbers, find all unique triplets in it that add up to zero: Sort the array. Here triplet is 0 means X+Y+Z=0. That means Y+Z = -X. In this case, we can take the first index and take 2 other indexes from the  end and start index +1. The start index can be skipped if it is a similar number. Now the problem is similar to above. Find the sum of the target number. We have to write a condition skip if continuous numbers are similar.
5. Given an array of unsorted numbers and a target number, find a triplet in the array whose sum is as close to the target number as possible, return the sum of the triplet. If there are more than one such triplet, return the sum of the triplet with the smallest sum : Sort the array. Will take 2 pointers start and end. There will be another pointer which is part of the for loop. We have to find the differences between the target sum and the sum of the arr[i]+arr[start]+arr[end]. If differences equal to zero return target sum. If the difference is more then increase the start else decrease the end. We have to handle the smallest sum when we have more than one solution.
6. Given an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] < target where i, j, and k are three different indices. Write a function to return the count of such triplets : This is similar to the target sum only. We have to keep track of a lesser sum from the target. The only difference we can take the count of the entire (end - start) where the sum of 2 starts & ends is equal to the third number.
7. Given an array with positive numbers and a positive target number, find all of its contiguous subarrays whose product is less than the target number. : It's similar to the above problems. We can take 2 pointers and start doing product. Here we have to start with the initial index and next to the initial index. First Product initializes with 1. Then start multiplying. If it's more than target then we have to reduce it from the start like the sliding window. Also while creating a list of substrings use LinkedList and add the number in 0th index.
8. Given an array containing 0s, 1s and 2s, sort the array in-place. You should treat the numbers of the array as objects, hence, we can’t count 0s, 1s, and 2s to recreate the array. : Take 2 pointers from start & end. Will start iterating from the front. Put three conditions for 0,1,2. If 1 then increase the index. If 0 then swap with start index. start++ and increase index. else swap with end index.
9.  Given an array of unsorted numbers and a target number, find all unique quadruplets in it, whose sum is equal to the target number.: Its similar to sum of target values. The only thing is to create a unique list we have to skip similar numbers. We can start by taking the first element and the next elements.         ```
    for (int i = 0; i < arr.length - 3; i++) {
      if (i > 0 && arr[i] == arr[i - 1]) // skip same element to avoid duplicate quadruplets
        continue;
      for (int j = i + 1; j < arr.length - 2; j++) {
        if (j > i + 1 && arr[j] == arr[j - 1]) // skip same element to avoid duplicate quadruplets
          continue;
        searchPairs(arr, target, i, j, quadruplets);
      }
    }
 ```
11. Given two strings containing backspaces (identified by the character ‘#’), check if the two strings are equal.: Start from end take 2 pointers for 2 strings. Write a method that will return the valid index. Pass each index and compare for both strings. If both string reaches to index 0 that means same else false.
12. Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array. : Take 2 pointers from start and end. Find the unsorted index from start and end. Then find the max and min value of the subarray. Then check from the start and compare with the min value of the sub-array and similarly do from the end with max value.    
