- Given a binary tree and a number ‘S’, find if the tree has a path from root to leaf such that the sum of all the node values of that path equals ‘S’.
   - We will use recursion for this solution
   - create a function that will take 2 inputs root node and target sum. Return boolean
   - Add base condition if root equals null return false
   - If target sum equals root val and root of left and right null then return true. if(targetSum==root.val && root.left==null && root.right==null) return true
   - Call the same method to pass the left node of the root and target sum minus current value similarly with or condition call right node. return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val)
- Given a binary tree and a number ‘S’, find all paths from root to leaf such that the sum of all the node values of each path equals ‘S’.
   - Here also we will use recursion.
   - Define a function that will take 4 inputs root node, target sum, and list of nodes in the current path, a list of list nodes that match the sum path. Return void.
   - Add a base condition like the one above and return blank if the root equals null.
   - Add current value to the list of the current path
   - If the current value is equal to the target sum and the left and right values of the current node are equal to null then create a new list using the current list path and add to the final list of list.
   - else call the same method pass the left and right nodes and do minus the current value from the target sum. findPathsRecursive(currentNode.left, sum - currentNode.val, currentPath, allPaths); findPathsRecursive(currentNode.right, sum - currentNode.val, currentPath, allPaths);
   - remove the last element from the list of the current path. currentPath.remove(currentPath.size()-1)
 
- Given a binary tree, return all root-to-leaf paths.
   - This is similar to the above we do not need to put a condition for the target sum. In fact it's not an input so only we have to check if the current node is a leaf node or not. Means if(root.left==null && root.right==null)
   - Rest everything we can keep same to get the all root to leaf path.
- Given a binary tree, find the root-to-leaf path with the maximum sum.
   - We can take the static value which will track the max value along all paths.
   - Also we have to pass the current sum in the path instead of the list of current values.
   - Add base condition if root null returns 0
   - add current value to find the current sum
   - If the leaf node then check whether the sum is greater than the global sum or not. Update based on condition
   - Else call the same method with the left and right node
   - minus the current value from the current sum.
 
- Given a binary tree where each node can only have a digit (0-9) value, each root-to-leaf path will represent a number. Find the total sum of all the numbers represented by all paths.
    - Here also we will do recursively. The method will take 2 inputs root and pathSum.
    - Add base condition if root equals null return 0
    - calculate path sum. pathSum = 10*pathSum+root.val
    - if the leaf node returns pathSum
    - call the same method once with the left node and right node with path sum. then the sum of both. return findRootToLeafPathNumbers(currentNode.left, pathSum) + findRootToLeafPathNumbers(currentNode.right, pathSum);

- Given a binary tree and a number sequence, find if the sequence is present as a root-to-leaf path in the given tree.
   - Here also we have to iterate through all nodes in the tree and return true once all the elements.
   - So we will return null and pass 3 elements one root node and another index which will be used to fetch value from the sequence list, also pass the sequence list.
   - Add base condition if root is null return false
   - Another base condition is if the index is greater than the seq array size or the seq of the index value is not equals to the root of val then return false. if (sequenceIndex >= sequence.length || currentNode.val != sequence[sequenceIndex])
   - If the leaf node then returns true
   - call the same method once with the left node and another time with the right node. Pass the index by incrementing one.return findPathRecursive(currentNode.left, sequence, sequenceIndex + 1) || findPathRecursive(currentNode.right, sequence, sequenceIndex + 1);
 
- Given a binary tree and a number ‘S’, find all paths in the tree such that the sum of all the node values of each path equals ‘S’. Please note that the paths can start or end at any node but all paths must follow directions from parent to child (top to bottom).
   - This can be solved in 2 ways O(N^2) which can be followed like the way to solve all root-to-leaf paths and find a specific sum and O(N) solution using the map.
   - Provide 3 inputs. Root node, target sum, and list ofthe  current path and return pathCount.
   - Add base condition root == null return 0
   - add current val in the current path list
   - initialize pathCount and pathSum equal to 0
   - Take an iterator and add values from the current path list to find the sum of the current path values.  ListIterator<Integer> pathIterator = currentPath.listIterator(currentPath.size());
   - iterate while loop from back and add to the pathSum
   - if pathSum equals target sum then increase counter
   - call the same method for the left node and assign it to pathSum pathCount += countPathsRecursive(currentNode.left, S, currentPath);
   - Same for the right node pathCount += countPathsRecursive(currentNode.right, S, currentPath);
   - in the end, remove the current value from currentPath list
 
      - O(n) solution can be done using Prefix Sum 
- Given a binary tree, find the length of its diameter. The diameter of a tree is the number of nodes on the longest path between any two leaf nodes. The diameter of a tree may or may not pass through the root.
     - Create a global static value to store max distance between the longest leaf nodes
     - Take function where will pass the root and output will be in int
     - Add a base condition if root equals null return 0
     - take an int to calculate the left height call the same method and pass the left node of the root.
     - take another int to calculate the right height call the same method and pass the left node of the root.
     - if leaf height is not equal to 0 and right height is not equal to 0 then sum of left height and right height plus 1. if (leftTreeHeight != 0 && rightTreeHeight != 0)  int diameter = leftTreeHeight + rightTreeHeight + 1;
     - Update the global variable by comparing the global variable and the sum of 2 diameters.
     - finally return max of leftDiameter and  rightDiameter +1. Math.max(leftTreeHeight, rightTreeHeight) + 1; 
- Find the path with the maximum sum in a given binary tree. Write a function that returns the maximum sum. A path can be defined as a sequence of nodes between any two nodes and doesn’t necessarily pass through the root. The path must contain at least one node.
    - This is similar to the above but we have to do the sum of the node's value
    - Create a global static value to store max value
    - add base condition if root equal null return 0
    - call the same method with the left node and assign leftNodesValue
    - call the same method with the right node and assign rightNodesValue
    - check current left value greater than 0 or not to avoid adding a negative value maxPathSumFromLeft = Math.max(maxPathSumFromLeft, 0);
    - check current right value greater than 0 or not to avoid adding a negative value maxPathSumFromRight = Math.max(maxPathSumFromRight, 0);
    - find the current sum of leftNodesValue and rightNodesValue and current val int localMaximumSum = maxPathSumFromLeft + maxPathSumFromRight + currentNode.val;
    - update the global sum based on the comparison
    - return the max of left sum and right sum then add the current value. return Math.max(maxPathSumFromLeft, maxPathSumFromRight) + currentNode.val;
