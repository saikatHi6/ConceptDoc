- Given a binary tree and a number ‘S’, find if the tree has a path from root to leaf such that the sum of all the node values of that path equals ‘S’.
   - We will use recursion for this solution
   - create a function that will take 2 inputs root node and target sum. Return boolean
   - Add base condition if root equals null return false
   - If target sum equals root val and root of left and right null then return true. if(targetSum==root.val && root.left==null && root.right==null) return true
   - Call the same method to pass the left node of the root and target sum minus current value similarly with or condition call right node. return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val)
- Given a binary tree and a number ‘S’, find all paths from root to leaf such that the sum of all the node values of each path equals ‘S’.
   - Here also we will use recursion.
   - Define a function that will take 4 inputs root node, target sum, and list of nodes in the current path, a list of list nodes that match the sum path. Return void.
   - Add a base condition like the one above and return blank if the root equals null.
   - Add current value to the list of the current path
   - If the current value is equal to the target sum and the left and right values of the current node are equal to null then create a new list using the current list path and add to the final list of list.
   - else call the same method pass the left and right nodes and do minus the current value from the target sum. findPathsRecursive(currentNode.left, sum - currentNode.val, currentPath, allPaths); findPathsRecursive(currentNode.right, sum - currentNode.val, currentPath, allPaths);
   - remove the last element from the list of the current path. currentPath.remove(currentPath.size()-1)
 
- Given a binary tree, return all root-to-leaf paths.
   - This is similar to the above we do not need to put a condition for the target sum. In fact it's not an input so only we have to check if the current node is a leaf node or not. Means if(root.left==null && root.right==null)
   - Rest everything we can keep same to get the all root to leaf path.
- Given a binary tree, find the root-to-leaf path with the maximum sum.
   - We can take the static value which will track the max value along all paths.
   - Also we have to pass the current sum in the path instead of the list of current values.
   - Add base condition if root null returns 0
   - add current value to find the current sum
   - If the leaf node then check whether the sum is greater than the global sum or not. Update based on condition
   - Else call the same method with the left and right node
   - minus the current value from the current sum.
 
- Given a binary tree where each node can only have a digit (0-9) value, each root-to-leaf path will represent a number. Find the total sum of all the numbers represented by all paths.
    - Here also we will do recursively. The method will take 2 inputs root and pathSum.
    - Add base condition if root equals null return 0
    - calculate path sum. pathSum = 10*pathSum+root.val
    - if the leaf node returns pathSum
    - call the same method once with the left node and right node with path sum. then the sum of both. return findRootToLeafPathNumbers(currentNode.left, pathSum) + findRootToLeafPathNumbers(currentNode.right, pathSum);

- Given a binary tree and a number sequence, find if the sequence is present as a root-to-leaf path in the given tree.
   - Here also we have to iterate through all nodes in the tree and return true once all the elements.
   - So we will return null and pass 3 elements one root node and another index which will be used to fetch value from the sequence list, also pass the sequence list.
   - Add base condition if root is null return false
   - Another base condition is if the index is greater than the seq array size or the seq of the index value is not equals to the root of val then return false. if (sequenceIndex >= sequence.length || currentNode.val != sequence[sequenceIndex])
   - If the leaf node then returns true
   - call the same method once with the left node and another time with the right node. Pass the index by incrementing one.return findPathRecursive(currentNode.left, sequence, sequenceIndex + 1) || findPathRecursive(currentNode.right, sequence, sequenceIndex + 1);
 
- Given a binary tree and a number ‘S’, find all paths in the tree such that the sum of all the node values of each path equals ‘S’. Please note that the paths can start or end at any node but all paths must follow direction from parent to child (top to bottom).
- Given a binary tree, find the length of its diameter. The diameter of a tree is the number of nodes on the longest path between any two leaf nodes. The diameter of a tree may or may not pass through the root.
- Find the path with the maximum sum in a given binary tree. Write a function that returns the maximum sum. A path can be defined as a sequence of nodes between any two nodes and doesn’t necessarily pass through the root. The path must contain at least one node.
